1. [User implementation](../context/src/concepts/User/implementation.ts/20251019_134059.56d63478.md): When I first implemented the functions, for the checks (such as whether the new username was unique), I threw errors when the **requires** conditions were not satisfied. However, when I tried to test those functions to make sure they handled failure cases properly, the test cases always threw errors because they would call the functions which would then throw errors. This was bad since there was no way for me to pass the test cases in that case. So, I instead changed the functions so that they did not throw errors, and instead printed the error message then returned (which broke the flow and prevented the rest of the function from executing). This meant that as long as everything was implemented correctly, the test cases would pass and not throw errors, and would also display the proper error message from the implementation, which fixed the issue. Note that this would also have applied to any other implementations, I just implemented the user concept first which is why I noticed the issue in that concept.
2. [User testing](../context/src/concepts/User/testing.ts/20251019_195246.a7519a32.md): When I implemented the first test case for user, I discovered that the type-checking nature of typescript meant that even if I defined user as an object that would clearly not be undefined, since the declaration function can return either user or void, so the type check has to be done before any operations that assume user to be of type user (and not undefined) can be performed. 
3. [Space testing](../context/src/concepts/Space/testing.ts/20251019_202025.0388de51.md): When I implemented the test cases for space, I realized that I needed functions such as getSpaceName and getSpaces, which I went back to implement in the space implementation. Although I could have acquired the spaces list/space name directly from the property (i.e. spaces_test.spaces), having these functions is helpful because if they'll be implemented in user interactions, this protects the state of the concept and only exposes things that are absolutely necessary. 
4. [Item implementation](../context/src/concepts/Item/implementation.ts/20251019_203119.beb316ec.md): When I implemented the updateItemDetails function, I realized that it would make more sense for the function to still work if none of the parameters exist, since that's equivalent to an update with empty fields, which should just leave the item as it is. I also realized that it was important to check that the new item name (if the item was renamed) would not result in duplicates, so I added that to both the implementation and the specification conditions. 
5. [LocationLog Implementation](../context/src/concepts/LocationLog/implementation.ts/20251019_213800.2379dc3c.md): When I implemented the LocationLog concept, I realized that it was necessary to do a createLog function. This was further solidified when I did the tests for LocationLog. Creating the log was necessary in order to perform actions and tests on it, and although placeItem could create the logs if they didn't exist already, having a separate action for that makes the whole concept more modular and ready for change. 
6. [Bundle Implementation](../context/src/concepts/Bundle/implementation.ts/20251019_213958.ebc09953.md): When I implemented the deleteBundle vs. add/remove item from bundle functions, I realized that there needed to be a difference between the bundle parameters used in them--for the former, the bundle name should be used, to avoid confusion with accessing deleted bundles in case of any errors, but for the latter, using the bundle object made the actions more modular and easy to understand. 